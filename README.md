# GoMessage

<br>

[中文文档](https://www.yuque.com/osoc/gomessage) | [English Document](https://www.yuque.com/osoc/gomessage-en)


## 用途说明：

GoMessage是一款消息转发器，主要功能为：

- 用`更友好的图形界面的方式`补全`Prometheus + Alertmanager`
  报警链路中的最后一个环节，接收Alertmanager报警消息推送，`完成消息格式化`后转发到指定客户端上。
- 接收其它工具的消息推送（例如Git的`WebHook回调`），`完成消息格式化`后转发到指定客户端上。
- 接收`任意Json结构`的消息推送，`完成消息格式化`后转发到指定客户端上...

软件特色：

- 一次接收，多端推送

- 切割AlertManager消息中的数组，把`Alertmanager聚合组中`聚合起来的消息切割为`单条`然后逐一发送

- 原始数据劫持，可以直观的观察到上游推送过来的json数据结构

- 模板支持`if...else`、`for循环`等逻辑门编写

- 模板支持`Markdown语法`编写

- 模板支持`文本`中插入`CSS样式标签`来控制字体颜色或其它样式渲染

<br><br>

## 投产架构：

![](https://img.taycc.com/2021-12-27-GoMessage.png)


<br>

## 版本说明：

假设当前版本为：`v2.3.6`
- 2代表大版本：表示底层架构发生了`向前不兼容`的更新或变动。
- 3代表中版本：表示底层架构依然`向前兼容`，但是`增加了新的功能`。
- 6代表小版本：表示`没有增加`任何新功能，只是`对已知的问题和BUG进行了修复`。

[查看所有的版本](https://github.com/gomessage/gomessage/releases)

<br><br>

## 体验地址：

点击右侧地址进行体验：[http://47.102.46.109:7077](http://47.102.46.109:7077)

**（作者是个人开发者，体验服务器只有1MB的带宽，加载较慢请稍稍见谅~）**

> 小提示：
> - GoMessage的设计初衷就把它定位为`内网基础设施工具`，因此没有设计`账号密码及权限相关`的模块，广大用户可以借助Nginx的Base登录来控制相关权限。
> - 不排除以后会追加设计权限控制模块，但近期更新的版本暂时不考虑`权限模块`的开发。
> - 加作者微信 `SPE3SRU3STAY` 进入GoMessage技术交流群。




<br><br>

## 安装步骤：


- [使用Docker部署（强烈推荐，满足日常内网使用场景）](wiki/install_docker.md)


- [在Linux裸机上部署（稳定性经过生产验证，部署过程略微繁琐）](wiki/install_linux.md)


- [使用Helm Chart在Kubernetes集群中部署（不完美支持、还在不断封装中）](wiki/install_helm.md)


- [使用Yaml脚本在Kubernetes集群中部署（完美支持）](wiki/install_yaml.md)


- [在Windows机器上启动](wiki/install_windows.md)


- [在Mac机器上启动](wiki/install_mac.md)


<br><br>

## 安装包下载：

安装包下载地址（国内）：https://gitee.com/gomessage/gomessage/releases （这个地址国内访问速度快~）

安装包下载地址（国外）：https://github.com/gomessage/gomessage/releases

> 目前提供有Linux、Mac、Windows三个版本的安装包（x86_64架构），如需支持其它版本，可以自行下载源码编译，也可以直接联系作者编译出指定版本的安装包。

<br><br>

## 界面上的使用教程

（下图是v2.0版的界面，不排除后面版本中会对界面UI进行调整）



### 多通道设计

> `v2.x.x`版最大的一个特色就是可以`多通道`并发工作：

![image-20230612224906295](https://img.taycc.com/image-20230612224906295.png)

每个通道都会自动生成一个独立的消息入口，如上图所示的那样：

- `default通道`消息入口：`http://gomessage.taycc.top/go/message` 
- `prometheus通道`消息入口：`http://gomessage.taycc.top/go/prometheus`



通道的命名规则为：`http://<您的服务器地址>/go/<您的通道名称>`，例如：

```bash
- http://192.168.33.201:7077/go/message
 
- http://192.168.33.201:7077/go/default 

- http://192.168.33.201:7077/go/<prometheus>

- http://192.168.33.201:7077/go/<zabbix>

- http://192.168.33.201:7077/go/<dev>

- http://192.168.33.201:7077/go/<fat>

- http://192.168.33.201:7077/go/<prod>
```



> PS：当`通道名称`为`default`时，GoMessage的域名生成模块会用`message`来代替`default`这个单词拼写显示在UI界面上，二者在路由层面的功能是一样的，此时 `路由/go/message` == `路由/go/default` ; 
>
> 
>
> 也就是说，您向以下两个地址推送消息时，效果是等价的：
>
> - `http://192.168.33.201:7077/go/message` 
>
> - `http://192.168.33.201:7077/go/default`
>
>   
>
> 这种特殊的设计，只是为了让用户在部署完GoMessage后，不用增加记忆负担，直接就可以有一个默认的default通道来进行使用。如果您不需要这个通道，随时可以进行删除。


<br><br>

### 创建一个新的通道

可以通过点击左侧的【管理推送通道】按钮，来对通道进行`增、删、改、查`操作。

需要注意的是：一旦删除`某个通道`，那么该通道下的``所有资源`都会被删除，您可以很干净的来管理您的推送通道。

会被删除的内容如下：

- 消息模板
- 接收客户端
- 用户变量映射

![image-20230612230804968](https://img.taycc.com/image-20230612230804968.png)

### 使用通道的正确姿势

一个通道，由以下三要素组成：

- 消息接收入口（接收上游的消息推送，只接受Post方式推送）
- 内容体渲染（上游推送过来的消息是json格式，此时把json渲染成人类可读的信息体）
- 接收客户端（把渲染后的信息体，推送给指定的接收客户端）


<br><br>

#### 消息接收入口

每个通道的首页有两个很醒目的内容：

- `消息推送地址`的框框：这个被全自动识别出来的地址，就是当前通道的消息入口；直接粘贴这个地址给“上游的消息推送者“使用即可，不用做任何额外的处理，直接粘贴走就能用。
- `模拟报警`的按钮：考虑到很多用好刚创建好一个GoMessage通道时，想要快速的测试一下”当前通道“是否通畅。因此这里内嵌了一个”测试按钮“，点击这个按钮就会向`当前通道`推送一条json信息。该json内容是截取的一段Alertmanager报警流中推送出来的信息，数据结构同时包含`数组、字典、多层嵌套`等等的，数据结构很具有代表性，可以做各种复杂的推送测试。

![image-20230612232037784](https://img.taycc.com/image-20230612232037784.png)


<br><br>

### 接收客户端

![image-20230612232722386](https://img.taycc.com/image-20230612232722386.png)

![image-20230612232813206](https://img.taycc.com/image-20230612232813206.png)

只需要点击【添加新客户端】按钮，可以创建对应的接收客户端。具体每个客户端【输入框】中的内容应该如何填写，参见下面详细的教程说明：

- [创建一个钉钉客户端](wiki/client_dingtalk.md)
- [创建一个飞书客户端](wiki/client_feishu.md)
- [创建一个企业微信客户端](wiki/client_wechat1.md)
- [创建一个飞书客户端](wiki/client_wechat2.md)

如果以上的客户端不能满足您的使用需求，您可以联系作者（作者微信：`SPE3SRU3STAY`）喊他帮您开发对应接收客户端。


<br><br>

### 数据渲染

一些想法（可以跳过不读）：

> 过去几年有个问题让我思考了很久：随着内网基础设施自动化覆盖面越来越广，过去的`人类主动去盯梢关注`某些节点的工作方式，可能会无法满应对`未来海量的机器信息`扑面而来的局面；自动化越先进的场景下，越会逐渐演变成`人类没有多余精力`来持续跟进`自动化全链路`中多重节点了。那我们可否换一个方式来思考：是不是能让`机器自动来向人类汇报！`
>
> 
>
> （请注意此处的侧重点）不再是机器把自身运行状况存储在某个中间的介质中`比如Promethus`，再借用Grafana用大盘展示出来；而是由机器或链路的某个节点，直接把自身某个运行状况主动的向人类推送汇报。人类只需要像读取微信消息一样，读取到机器发送的消息即可。
>
> 
>
> 那么在整个 `机器---通知--->人类` 的这个过程中，最被琐事淹没的环节就要数【`任意数据结构的json原始机器信息`都可以被转换成`人类可读的友好信息`的这个环节】最为占用我们的时间精力。具备开发力量的团队，可以使用Pyhon、Golang（或其它的某种开发语言）来编写一段程序，专门来干这个工作。但开发这个东西，开发者要分别阅读：钉钉客户端开发文档、微信客户端开发文档、飞书客户端开发文档、甚至短信发送开发文档、语音电话开发文档、等等。同时还要知道各种协议、标准、消息限流规范；甚至有的小伙伴还要关注程序运行的稳定性、高可用性，生产应急灾备恢复、等等的一堆问题。而缺乏开发力量的团队，则只能`通过增加人手去解决日益增长的需求`；面对这种客观存在的状况，在一定程度上浪费了团队的时间、精力、和珍贵的生产力。
>
> 
>
> 作者认为这些`不同厂商的开发文档阅读`、`消息内容的渲染`、`零碎的代码调试`、`重复的思维复杂度投入`等等此类琐事都应该被消灭。同时`消灭琐事`刚好符合SRE技术哲学追求的一个重要方向，因此GoMessage在设计之初，就秉承着`更加简单高效的`帮助用户解放时间和精力为理念。不断地优化和打磨`消息渲染模块`，试图追求一种 `简单、再简单、更简单、简单到优美`的一种使用方式。（但由于作者的水平有限，对复杂问题的思考可能缺乏特有的视角，因此接下来的`消息渲染功能`在使用体验上可能依然存在某种复杂度，在此恳请各位小伙伴能够给于一些宝贵的反馈和建议，作者会在业余时间对GoMessage会不断的迭代更新下去，我们一起去做振奋人心的事~）

<br>

GoMessage尽可能的设计了比较`简约、简单、且有广泛兼容性`的数据渲染方式，摆脱了传统的`去命令行里写配置文件`（或）`只能限定在较小的灵活度内`去编写模板的传统方式。操作界面截图如下：

![image-20230613002543541](https://img.taycc.com/image-20230613002543541-6651884.png)

剩下的明天再写~



<br><br>

## 交流和问题反馈：

微信扫码加入GoMessage技术交流群：

> 如果二维码失效可以添加作者微信号 `SPE3SRU3STAY` 邀请您进群。

<img src="./wiki/images/wechat.png" width="300" />

